---
star: true
category: 持久化
tag: 
  - Redis
  - database
---

# Redis
Redis (Remote Dictionary Server) 是一个开源的内存数据结构存储，用作数据库、缓存和消息代理。它支持多种数据结构，如字符串（strings）、哈希（hashes）、列表（lists）、集合（sets）以及有序集合（sorted sets）。因为具有丰富的功能和高性能，现在几乎主流的 Web 项目都已经绑定了 Redis 作为缓存组件。

## 特点
1. 内存存储：所有数据都保存在内存中，读写速度非常快，非常适合需要快速响应的场景。
2. 持久化：Redis支持将数据持久化到磁盘，可以通过快照（snapshot）和AOF（Append-Only File）两种方式进行。
3. 高可用性和分布式：通过 Redis Sentinel 实现高可用，通过Redis Cluster 实现数据分布和负载均衡。
4. 丰富的数据类型：支持多种数据结构，便于解决复杂的数据存储和操作问题。
5. Lua 脚本：支持 Lua 脚本，可以实现复杂的原子操作。
6. 事务支持：支持事务，保证一系列操作的原子性。

## 原理分析
### 为什么 Redis 那么快
1. 基于内存存储：Redis的所有数据都保存在内存中，读写速度非常快。
2. 多路 I/O 复用：Redis 使用多路 I/O 复用技术，可以同时处理多个客户端的请求，提高并发处理能力。
3. 高效的数据结构：Redis 支持多种数据结构，这些数据结构都进行了优化，可以快速处理。
4. Lua脚本：Redis支持 Lua 脚本，可以实现复杂的原子操作。
5. 语言实现：C 语言实现，性能很高。
6. 单线程模型：单线程无法充分利用多核，但另一方面，它避免了多线程的频繁上下文切换以及锁等同步机制的开销。

### 为什么选择单线程
1. 避免过多的上下文切换开销：在多线程调度过程中，需要在 CPU 之间切换线程上下文，并且上下文切换涉及一系列寄存器替换、程序堆栈重置，甚至包括程序计数器、堆栈指针和程序状态字等快速表项的退休。因为单个进程内的多个线程共享进程地址空间，线程上下文要比进程上下文小得多，在跨进程调度的情况下，需要切换整个进程地址空间。
2. 避免同步机制的开销：如果Redis选择多线程模型，因为 Redis 是一个数据库，不可避免地涉及底层数据同步问题，这必然会引入一些同步机制，如锁。我们知道Redis不仅提供简单的键值数据结构，还提供列表、集合、哈希等丰富的数据结构。不同的数据结构对于同步访问的锁定具有不同的粒度，这可能会在数据操作期间引入大量的锁定和解锁开销，增加了程序的复杂性并降低了性能。
3. 简单和可维护性：简单且可维护的代码必然是Redis在早期的核心准则之一，引入多线程不可避免地导致了代码复杂性的增加和可维护性的降低。

### Redis 真的是单线程的吗？
需要看版本来说，对于网络模型来说，Redis 在 v6.0 之前一直是单线程的，在 v6.0 之后正式在网络模型中实现I/O多线程；对于整个 Redis 中，在 v4.0 版本中就引入多线程进行异步任务。
Redis在v4.0版本中引入了多线程来执行一些异步操作，主要用于非常耗时的命令。通过将这些命令的执行设置为异步，可以避免阻塞单线程事件循环。

我们知道 Redis 的 DEL 命令用于删除一个或多个键的存储值，它是一个阻塞命令。在大多数情况下，要删除的键不会存储太多值，最多几十个或几百个对象，因此可以快速执行。但如果要删除具有数百万个对象的非常大的键值对，则此命令可能会阻塞至少几秒钟，由于事件循环是单线程的，它会阻塞随后的其他事件，从而降低吞吐量。

## 场景
### 抽象场景
1. 缓存（Caching）：
- 对需要频繁访问的数据进行缓存，如用户信息、商品信息等。
- 极大提高数据的读取速度，减轻数据库负载。
2. 会话存储（Session Store）：
- 场景：在Web应用中，将用户会话信息存储在Redis中，如登录状态、购物车等。
- 好处：读取速度快，支持持久化，可以实现分布式会话管理。
3. 实时数据分析（Real-time Analytics）：
- 场景：用于实时统计和分析，如网站的访问量统计、实时排名等。
- 好处：通过内存操作实现快速数据处理和统计。
4. 消息队列（Message Queue）：
- 场景：利用Redis的列表（List）或发布/订阅（Pub/Sub）机制实现消息队列，进行异步任务处理。
- 好处：简单易用，适合中小规模的消息队列需求。
5. 排行榜（Leaderboard）和计数器（Counting）：
- 场景：实现各种排行榜功能，如游戏排名、积分榜等。
- 好处：通过有序集合（sorted set）快速实现排名和分数统计。
6. 分布式锁（Distributed Lock）：
- 场景：在分布式系统中实现锁机制，确保同一资源不会被多个进程同时修改。
- 好处：利用Redis的原子操作，实现简单有效的分布式锁。
7. 地理信息存储和查询（Geospatial Information Storage and Query）：
- 场景：存储和查询地理位置数据，如定位服务、地图应用等。
- 好处：通过geo命令集快速实现地理位置的存储和半径查询。

### 实际场景
1. 阅读量/浏览量：配合 String 类型的 incr 原子增加操作，每次访问链接自动加一。

```card
title: Redis 官网
desc: 点击跳转官网查看详细内容
logo: /assets/images/study/persistence/redis/redis-cube.svg
link: https://redis.io/
color: rgba(173, 216, 590, 0.15)
```

## 缓存
目前系统的数据访问通常设计有有三种方式，第一种是简单的请求直接访问数据库，如果是在数据量和并发量很小的情况下，这种访问方式是可行的。但是当数据量很大，并发量很高时，这种访问方式就会导致数据库压力过大，从而影响系统的性能。

在这种情况之上就增加了缓存来缓解数据库的压力的第二种方式，请求进入先在缓存中查询数据信息，如果缓存中不存在再去访问数据库数据。这里的方案的实现也有两种：
1. 数据结构实现的代码层面的缓存，无论是自定义 Map 存储要缓存的数据，还是使用 Guava 等第三方缓存框架，这种方案的缺点是只能单机使用，并且占用内存会严重些。
2. 使用 Redis 作为缓存，天然支持分布式，并且灵活的使用数据结构可以达到优秀的效果，缺点是技术门槛和服务器成本较高。

第三种方式是在缓存的基础上增加布隆过滤器降低无效数据的访问来防止缓存穿透，这种方案的缺点是布隆过滤器需要维护，并且布隆过滤器的误判率需要控制。

## 布隆过滤器