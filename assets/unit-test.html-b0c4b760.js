const e=JSON.parse(`{"key":"v-3c645f4e","path":"/work-task/development/unit-test.html","title":"单元测试","lang":"zh-CN","frontmatter":{"category":"工作任务","tag":["Spring Boot","Java","Mockito"],"description":"单元测试 单元测试（Java语言中）是对类中每个方法提供一个或多个测试的一种实践，其目的是为了有规律的测试一个类的各个部分是否具备正确的行为。 ——摘自《Java 编程思想》 引言 刚开始工作的时候谁写测试类啊，还单元测试呢，测试我都不测试。后来到了正式一些的公司之后，不通过质量门禁则不能上线，所以 JaCoCo 这个开源的单元测试引擎就发挥作用了，它搭配 Sonar 面板可以展示单元测试对代码的覆盖程度、帮助开发团队分析测试覆盖率，并且了解哪些代码已经被测试覆盖，以及哪些代码尚未被测试覆盖。尽管如此，你的测试类还是很难保证你的代码所有逻辑分支都可以覆盖的到，于是 Mock 又出现了，相对于 Junit 它提供了简洁的API，使得在单元测试中创建模拟对象、定义模拟对象的行为以及验证方法的调用变得非常容易。所以我们选择使用 Mock 搭配 JUnit 作为最佳解决方案。","head":[["meta",{"property":"og:url","content":"https://github.com/songbaicheng/songbaicheng.github.io/work-task/development/unit-test.html"}],["meta",{"property":"og:site_name","content":"Baicheng's Blog"}],["meta",{"property":"og:title","content":"单元测试"}],["meta",{"property":"og:description","content":"单元测试 单元测试（Java语言中）是对类中每个方法提供一个或多个测试的一种实践，其目的是为了有规律的测试一个类的各个部分是否具备正确的行为。 ——摘自《Java 编程思想》 引言 刚开始工作的时候谁写测试类啊，还单元测试呢，测试我都不测试。后来到了正式一些的公司之后，不通过质量门禁则不能上线，所以 JaCoCo 这个开源的单元测试引擎就发挥作用了，它搭配 Sonar 面板可以展示单元测试对代码的覆盖程度、帮助开发团队分析测试覆盖率，并且了解哪些代码已经被测试覆盖，以及哪些代码尚未被测试覆盖。尽管如此，你的测试类还是很难保证你的代码所有逻辑分支都可以覆盖的到，于是 Mock 又出现了，相对于 Junit 它提供了简洁的API，使得在单元测试中创建模拟对象、定义模拟对象的行为以及验证方法的调用变得非常容易。所以我们选择使用 Mock 搭配 JUnit 作为最佳解决方案。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-08-14T09:10:13.000Z"}],["meta",{"property":"article:author","content":"songbaicheng"}],["meta",{"property":"article:tag","content":"Spring Boot"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:tag","content":"Mockito"}],["meta",{"property":"article:modified_time","content":"2023-08-14T09:10:13.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"单元测试\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-08-14T09:10:13.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"songbaicheng\\",\\"url\\":\\"https://github.com/songbaicheng\\",\\"email\\":\\"songbaicheng16@163.com\\"}]}"]]},"headers":[{"level":2,"title":"引言","slug":"引言","link":"#引言","children":[]},{"level":2,"title":"质量门襟要求","slug":"质量门襟要求","link":"#质量门襟要求","children":[]},{"level":2,"title":"规范的单元测试","slug":"规范的单元测试","link":"#规范的单元测试","children":[{"level":3,"title":"屏蔽内容限制","slug":"屏蔽内容限制","link":"#屏蔽内容限制","children":[]},{"level":3,"title":"用例强制要求","slug":"用例强制要求","link":"#用例强制要求","children":[]},{"level":3,"title":"用例建议要求","slug":"用例建议要求","link":"#用例建议要求","children":[]}]},{"level":2,"title":"单元测试用例思路","slug":"单元测试用例思路","link":"#单元测试用例思路","children":[]},{"level":2,"title":"Mock","slug":"mock","link":"#mock","children":[]},{"level":2,"title":"Mock 单元测试实践","slug":"mock-单元测试实践","link":"#mock-单元测试实践","children":[{"level":3,"title":"Mockito","slug":"mockito","link":"#mockito","children":[]},{"level":3,"title":"PowerMock","slug":"powermock","link":"#powermock","children":[]}]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"createdTime":1691748553000,"updatedTime":1692004213000,"contributors":[{"name":"songbaicheng","email":"2524218694@qq.com","commits":3}]},"readingTime":{"minutes":9.49,"words":2848},"filePathRelative":"work-task/development/unit-test.md","localizedDate":"2023年8月11日","excerpt":"<h1> 单元测试</h1>\\n<blockquote>\\n<p>单元测试（Java语言中）是对类中每个方法提供一个或多个测试的一种实践，其目的是为了有规律的测试一个类的各个部分是否具备正确的行为。 ——摘自《Java 编程思想》</p>\\n</blockquote>\\n<h2> 引言</h2>\\n<p>刚开始工作的时候谁写测试类啊，还单元测试呢，测试我都不测试。后来到了正式一些的公司之后，不通过质量门禁则不能上线，所以 JaCoCo 这个开源的单元测试引擎就发挥作用了，它搭配 Sonar 面板可以展示单元测试对代码的覆盖程度、帮助开发团队分析测试覆盖率，并且了解哪些代码已经被测试覆盖，以及哪些代码尚未被测试覆盖。尽管如此，你的测试类还是很难保证你的代码所有逻辑分支都可以覆盖的到，于是 Mock 又出现了，相对于 Junit 它提供了简洁的API，使得在单元测试中创建模拟对象、定义模拟对象的行为以及验证方法的调用变得非常容易。所以我们选择使用 Mock 搭配 JUnit 作为最佳解决方案。</p>","autoDesc":true}`);export{e as data};
