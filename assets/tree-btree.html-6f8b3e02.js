import{_ as r}from"./plugin-vue_export-helper-c27b6911.js";import{r as s,o as i,c as o,b as t,d as e,e as n,w as d,a as c}from"./app-8eda1cf8.js";const l="/assets/images/study/computer-basis/ads/data-structure/tree-btree/wpl.jpg",g="/assets/images/study/computer-basis/ads/data-structure/tree-btree/hftree-process.jpg",h="/assets/images/study/computer-basis/ads/data-structure/tree-btree/hf-code.jpg",u={},p=c('<h1 id="树和二叉树的应用" tabindex="-1"><a class="header-anchor" href="#树和二叉树的应用" aria-hidden="true">#</a> 树和二叉树的应用</h1><h2 id="哈夫曼树和哈夫曼码" tabindex="-1"><a class="header-anchor" href="#哈夫曼树和哈夫曼码" aria-hidden="true">#</a> 哈夫曼树和哈夫曼码</h2><p>在许多应用中，树中结点常常被赋予一个表示某种意义的数值，称为该结点的<strong>权</strong>，从树的根结点到任意结点的路径长度与该结点上的权值的乘积，称为该结点的带权路径长。树中所有叶结点的带权路径长被称为该树的<strong>带权路径长</strong>（WPL）。</p><p>在含有 n 个带权叶结点的二叉树中，其中带权路径长度最小的二叉树称为<strong>哈夫曼树</strong>，也称为<strong>最优二叉树</strong>。</p><figure><img src="'+l+'" alt="具有不同带权长度的二叉树" tabindex="0" loading="lazy"><figcaption>具有不同带权长度的二叉树</figcaption></figure><h3 id="哈夫曼树的构造" tabindex="-1"><a class="header-anchor" href="#哈夫曼树的构造" aria-hidden="true">#</a> 哈夫曼树的构造</h3><figure><img src="'+g+'" alt="哈夫曼树的构造过程" tabindex="0" loading="lazy"><figcaption>哈夫曼树的构造过程</figcaption></figure><p>从上述的构造过程中可以看出哈夫曼树具有一下特点：</p><ol><li>每个初始结点最终都成了叶结点，且权值越小的结点到根结点的路径长度越大。</li><li>构造过程中新建了 n - 1 个分支结点，因此哈夫曼树的总结点数为 2n - 1。</li><li>每次构造都选择两棵树作为新结点的孩子，因此哈夫曼树不存在度为 1 的结点。</li></ol><h3 id="哈夫曼编码" tabindex="-1"><a class="header-anchor" href="#哈夫曼编码" aria-hidden="true">#</a> 哈夫曼编码</h3><p>在数据通讯中，若对每个字符用相等长度的二进制位表示，称这种编码方式为<strong>固定长度编码</strong>。若允许对不同字符用不等长的二进制表示，则这种编码方式称为<strong>可变长度编码</strong>，其特点是对频率高的字符覆以短编码，频率低的字符则赋予长编码，从而使字符的平均长度减短，起到压缩数据的作用，哈夫曼编码正是一种被广泛应用而且有效的数据压缩编码。</p><p>若没有一个编码是另一个编码的前缀，则称为这样的编码为<strong>前缀编码</strong>。由哈夫曼树得到哈夫曼编码是很自然的过程，其权值正好对应它出现的次数，构造出对应的哈夫曼树，我们将字符的编码解释为从根至该字符路径上边界的标记的序列，0 表示转向左孩子，1 表示转向右孩子。</p><figure><img src="'+h+'" alt="由哈夫曼树构成哈夫曼编码" tabindex="0" loading="lazy"><figcaption>由哈夫曼树构成哈夫曼编码</figcaption></figure><h2 id="并查集" tabindex="-1"><a class="header-anchor" href="#并查集" aria-hidden="true">#</a> 并查集</h2>',14);function f(m,_){const a=s("RouterLink");return i(),o("div",null,[p,t("blockquote",null,[t("p",null,[e("参考算法模块中的"),n(a,{to:"/study/computer-basis/ads/algorithms/disjoint-set-union.html"},{default:d(()=>[e("并查集")]),_:1}),e("。")])])])}const y=r(u,[["render",f],["__file","tree-btree.html.vue"]]);export{y as default};
