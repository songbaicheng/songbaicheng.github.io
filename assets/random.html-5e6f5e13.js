const e=JSON.parse(`{"key":"v-a32a5efa","path":"/study/development/random.html","title":"全局随机数","lang":"zh-CN","frontmatter":{"category":"随机数","tag":["分布式 ID"],"description":"全局随机数 在随着数据库数据单机达到瓶颈已经无法支持的时候就会出现分库分表的场景，这个时候数据库自带的自增主键或者简单组成的随机数已经不能满足需求了，这个时候就需要使用全局唯一 ID。 一个最基本的分布式 ID 需要满足下面这些要求： 全局唯一：ID 的全局唯一性肯定是首先要满足的。 高性能：分布式 ID 的生成速度要快，对本地资源消耗要小。 高可用：生成分布式 ID 的服务要保证可用性无限接近于 100%。 方便易用：拿来即用，使用方便，快速接入。 除了这些之外，一个比较好的分布式 ID 还应保证：","head":[["meta",{"property":"og:url","content":"https://github.com/songbaicheng/songbaicheng.github.io/study/development/random.html"}],["meta",{"property":"og:site_name","content":"Baicheng's Blog"}],["meta",{"property":"og:title","content":"全局随机数"}],["meta",{"property":"og:description","content":"全局随机数 在随着数据库数据单机达到瓶颈已经无法支持的时候就会出现分库分表的场景，这个时候数据库自带的自增主键或者简单组成的随机数已经不能满足需求了，这个时候就需要使用全局唯一 ID。 一个最基本的分布式 ID 需要满足下面这些要求： 全局唯一：ID 的全局唯一性肯定是首先要满足的。 高性能：分布式 ID 的生成速度要快，对本地资源消耗要小。 高可用：生成分布式 ID 的服务要保证可用性无限接近于 100%。 方便易用：拿来即用，使用方便，快速接入。 除了这些之外，一个比较好的分布式 ID 还应保证："}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-07-16T14:19:20.000Z"}],["meta",{"property":"article:author","content":"songbaicheng"}],["meta",{"property":"article:tag","content":"分布式 ID"}],["meta",{"property":"article:modified_time","content":"2024-07-16T14:19:20.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"全局随机数\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-07-16T14:19:20.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"songbaicheng\\",\\"url\\":\\"https://github.com/songbaicheng\\",\\"email\\":\\"songbaicheng16@163.com\\"}]}"]]},"headers":[{"level":2,"title":"常见分布式 ID 设计方案","slug":"常见分布式-id-设计方案","link":"#常见分布式-id-设计方案","children":[{"level":3,"title":"数据库号段模式","slug":"数据库号段模式","link":"#数据库号段模式","children":[]},{"level":3,"title":"缓存数据库","slug":"缓存数据库","link":"#缓存数据库","children":[]},{"level":3,"title":"UUID","slug":"uuid","link":"#uuid","children":[]},{"level":3,"title":"Snowflake (雪花算法)","slug":"snowflake-雪花算法","link":"#snowflake-雪花算法","children":[]}]}],"git":{"createdTime":1721139560000,"updatedTime":1721139560000,"contributors":[{"name":"songbaicheng","email":"songbaicheng16@163.com","commits":1}]},"readingTime":{"minutes":4.23,"words":1268},"filePathRelative":"study/development/random.md","localizedDate":"2024年7月16日","excerpt":"<h1> 全局随机数</h1>\\n<p>在随着数据库数据单机达到瓶颈已经无法支持的时候就会出现分库分表的场景，这个时候数据库自带的自增主键或者简单组成的随机数已经不能满足需求了，这个时候就需要使用全局唯一 ID。 一个最基本的分布式 ID 需要满足下面这些要求：</p>\\n<ul>\\n<li>全局唯一：ID 的全局唯一性肯定是首先要满足的。</li>\\n<li>高性能：分布式 ID 的生成速度要快，对本地资源消耗要小。</li>\\n<li>高可用：生成分布式 ID 的服务要保证可用性无限接近于 100%。</li>\\n<li>方便易用：拿来即用，使用方便，快速接入。</li>\\n</ul>\\n<p>除了这些之外，一个比较好的分布式 ID 还应保证：</p>","autoDesc":true}`);export{e as data};
