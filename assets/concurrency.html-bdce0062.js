import{_ as a}from"./plugin-vue_export-helper-c27b6911.js";import{o as e,c as r,d as n}from"./app-ef7c0918.js";const c={},h=n('<h1 id="并发" tabindex="-1"><a class="header-anchor" href="#并发" aria-hidden="true">#</a> 并发</h1><h2 id="java-并发机制的底层原理" tabindex="-1"><a class="header-anchor" href="#java-并发机制的底层原理" aria-hidden="true">#</a> Java 并发机制的底层原理</h2><p>提到 Java 的编译过程，我们都会想到 .java 文件到 .class 字节码文件再到汇编指令到 CPU 内执行，而 Java 的并发机制正是依赖了 JVM 的实现和 CPU 的指令，让我们从 volatile 和 synchronized 这两个关键字来配合理解一下并发的原理。</p><h3 id="volatile" tabindex="-1"><a class="header-anchor" href="#volatile" aria-hidden="true">#</a> volatile</h3><h3 id="synchronized" tabindex="-1"><a class="header-anchor" href="#synchronized" aria-hidden="true">#</a> synchronized</h3>',5),i=[h];function t(d,o){return e(),r("div",null,i)}const _=a(c,[["render",t],["__file","concurrency.html.vue"]]);export{_ as default};
