import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as i,e as r}from"./app-467c4f8d.js";const h={},d=r('<h1 id="定时任务" tabindex="-1"><a class="header-anchor" href="#定时任务" aria-hidden="true">#</a> 定时任务</h1><h2 id="关于定时任务的使用场景" tabindex="-1"><a class="header-anchor" href="#关于定时任务的使用场景" aria-hidden="true">#</a> 关于定时任务的使用场景</h2><p>定时任务，定时任务，顾名思义，就是指定时执行某些特定操作或任务的功能。工作中的业务难免要定时任务打交道，网络上常见的定时任务场景有以下几种：</p><ul><li>数据备份：定时备份数据库、文件等数据，以防数据丢失或损坏。</li><li>数据统计：定时统计业务数据、用户行为数据等。</li><li>清理任务：定时清理缓存、日志、垃圾文件等。</li><li>自动化任务：定时执行自动化测试、自动化发布等任务。</li><li>资源管理：定时检查并释放资源，如数据库连接、内存等。</li><li>系统监控：定时检查系统运行状况，如 CPU 占用率、内存使用情况、磁盘空间等。</li></ul><h2 id="工作中遇到的定时任务场景" tabindex="-1"><a class="header-anchor" href="#工作中遇到的定时任务场景" aria-hidden="true">#</a> 工作中遇到的定时任务场景</h2><p>有一说一，一些高端的场景我倒是没有遇到过，但是思想和实现我感觉应该也是同样的基调，无非是放在哪里用是了。以下是工作中我遇到的定时任务场景。</p><h3 id="定期清理审批单" tabindex="-1"><a class="header-anchor" href="#定期清理审批单" aria-hidden="true">#</a> 定期清理审批单</h3><p>招录组织实施系统，其中有个环节是要求考生提交个人信息进行审核，审核的规则是这样的：每个审核人在审核时会从库里捞十个未审核的考生材料出来进行审核，被审核的考生材料会被标记为审核中，每份考生的材料同一时间只能被一位审核人审核。当时这样设计的初衷想想大概就是为了能加快审核进度，并且一次性加载十份材料也可以提升审批下一位时的体验，可是这样也有弊端，比如说有些审核人拉取完十位考生后不能进行后面审核，这几份考生的材料就会无法被其他审核人获取到从而导致无人审批，正因如此，为了解决有些材料一直无人审批的情况添加了一个定时任务，当一份材料被审核人抽取到转为审核中的时候，同时保存转换状态的时间，创建一个定时任务每过五分钟就遍历一下表中当前批次下已经在审核中状态超过半个小时的材料并重新将其置为未审核的状态，方便其他审核人去拿到这些可能存在不能及时审批隐患的材料。</p><p>其实现在想想这个逻辑还是存在不少问题的，比如说如果审核人正在审批一份超过30分钟或者已经被重新置为未审核的材料，此时审批人再去点击审批结果的时候发现审批已经失效，则会浪费多余的审批时间，这对于每次考试数十万考生的审批量无疑是个大问题。不过当时那已经是一个老项目了，也没有人提出重构的需求，放在现在如果仔细想想如果重新设计这个请求的话，应该不会采用这种方式一次获取十份材料的方式，像现在类似oss和一些高性能的架构的出现，已经不用太过担心体验和性能问题，这个定时任务的场景其实也正好能暴露时间轮的问题，并不是每份材料到了30分钟就会被重新标记为未审核，当然现在的时间轮算法估计已经足够精确，就算有误差也是可以忽略不计的。</p><h3 id="定期获取价格文件" tabindex="-1"><a class="header-anchor" href="#定期获取价格文件" aria-hidden="true">#</a> 定期获取价格文件</h3><p>接收价格的前置项目，我们和彭博约定在每天的四点请求获取每日的币种价格，彭博收到请求后将处理后的数据存放到公共的 ftp 服务器上，这里定时任务的需求就很明确了，为了保证一定可以拿到彭博处理的数据，我们会在四点五十去ftp获取价格文件，获取到价格后通过 MQ 推送到其他后台程序，当然就算是延后50分钟也不能保证每次都可以成功获取到每日价格文件，所以我们在每日的流水表中增加价格处理状态的字段，如果是获取不到文件则标记为 E 状态，每晚八点如果是今日获取价格文件的状态为 E 的重新执行一次获取价格文件，如果是其他错误状态则需要第二天人工排查问题。</p>',11),t=[d];function l(c,n){return a(),i("div",null,t)}const p=e(h,[["render",l],["__file","scheduled.html.vue"]]);export{p as default};
