import{_ as a}from"./plugin-vue_export-helper-c27b6911.js";import{o as e,c as i,e as t}from"./app-eda6fac5.js";const r="/assets/images/study/computer-basis/ads/data-structure/arrays-materices/arrays-row.jpg",d="/assets/images/study/computer-basis/ads/data-structure/arrays-materices/arrays-column.jpg",s="/assets/images/study/computer-basis/ads/data-structure/arrays-materices/sparse-matrix.jpg",c={},o=t('<h1 id="数组和特殊矩阵" tabindex="-1"><a class="header-anchor" href="#数组和特殊矩阵" aria-hidden="true">#</a> 数组和特殊矩阵</h1><p>矩阵在数据结构中考虑的是如何用最小的内存空间来存储同样的一组数据，所以我们应该把精力放在如何将矩阵更有效的存储在内存中，并能更方便的提取矩阵中的元素。通常矩阵在计算机语言中借助数组进行存储，我们首先认识一下数组的存储。</p><h2 id="数组" tabindex="-1"><a class="header-anchor" href="#数组" aria-hidden="true">#</a> 数组</h2><p>数组是由 n（n &gt;= 1）个相同类型的数据元素构成的有限序列，每个数据元素称为一个数组元素，每个元素在 n 个线性关系中的序号称为该元素的下标，下标的取值范围称为数组的边界。数组是线性表的推广，一维数组可视为一个线性表，二维数组可视为其元素也是定长线性表的线性表，以此类推。并且数组一点定义，其维数和维界就不会改变，因此，除结构的初始化和销毁操作外，数组只会有存取和修改元素的操作。</p><p>以一维数组 A[0……n-1] 为例，其存储的结构关系为 <code>LOC(ai) = LOC(a0) + i * L (0&lt;= i &lt; n)</code>，其中 L 是每个数组元素所占的存储单元。对于多维数组，有按行优先和按列优先两种映射方法。以二维数组为例，其基本思想是：先行后列，先存储行号较小的元素，行号相等先存储列号较小的元素，设二维数组的行下标与列下标的范围分别为[0, h1]与[1, h2]，则关系存储关系式为 <code>LOC(ai,j) = LOC(A0,0) + [i * (h2 + 1) + j] * L</code>。</p><figure><img src="'+r+'" alt="二维数组按行优先顺序存储" tabindex="0" loading="lazy"><figcaption>二维数组按行优先顺序存储</figcaption></figure><p>同理以列优先方式存储时，得出的存储结构关系式为 <code>LOC(ai,j) = LOC(A0,0) + [j * (h1 + 1) + j] * L</code>。</p><figure><img src="'+d+'" alt="二维数组按列优先顺序存储" tabindex="0" loading="lazy"><figcaption>二维数组按列优先顺序存储</figcaption></figure><h2 id="特殊矩阵" tabindex="-1"><a class="header-anchor" href="#特殊矩阵" aria-hidden="true">#</a> 特殊矩阵</h2><p>矩阵中有许多相同矩阵元素或者零元素的被称为特殊矩阵。为了节约存储空间，多个值相同的元素分配一个存储空间，或者对零元素不分配存储空间，所以要找出特殊矩阵中值相同的矩阵元素的分布规律，把那些呈现规律性分布、值相同的多个矩阵元素压缩到一个存储空间中。</p><h3 id="对称矩阵" tabindex="-1"><a class="header-anchor" href="#对称矩阵" aria-hidden="true">#</a> 对称矩阵</h3><p>若对一个 n 阶矩阵 A 中的任意一个元素都有 <code>ai,j = aj,i</code>，则称其为对称矩阵。其中的元素可以分为三个部分，上半区域、主对角线和下半区域，对于 n 阶对称矩阵，上三角区的的所有元素和下三角区的所有元素都是相同的，所以我们根据这个特性可以找到其对应规律：当在下三角区，即 i &gt;= j 的时候 <code>(i(i -1)) / 2 + j - 1</code>，在上三角区，即 i &lt; j 的时候 <code>(j(j - 1)) / 2 + i - 1</code>。</p><h3 id="三角矩阵" tabindex="-1"><a class="header-anchor" href="#三角矩阵" aria-hidden="true">#</a> 三角矩阵</h3><p>分为上三角矩阵和下三角矩阵，其中另外一半的元素全部都是一个元素，我们在对称矩阵的基础上，把另一半的元素放在另一半存储完的最后，在下三角矩阵中，即 i &gt;= j 的时候 <code>(i(i - 1)) / 2 + j - 1</code>，在 i &lt; j 的时候 <code>(n(n - 1)) / 2</code>；在上三角矩阵中，即 i &lt;= j 的时候 <code>((i -1)(2n - j + 2)) / 2 + j - j</code>，在 i &lt; j 的时候 <code>(n(n - 1)) / 2</code>。</p><h3 id="三对角矩阵" tabindex="-1"><a class="header-anchor" href="#三对角矩阵" aria-hidden="true">#</a> 三对角矩阵</h3><p>对角矩阵也叫袋状矩阵，对于 n 阶矩阵 A 中的任意一个元素 ai,j，当 |i - j| &gt; 1 时，ai,j = 0 (1 &lt;= i, j &lt;= n)，则称为三对角矩阵。三对角矩阵将三条对角线上的元素按照行优先方式存放在一维数组中，将 a1,1 放入数组第一个元元素中，则在数组中的下标符合 <code>k = 2i + j - 3</code>。如果我们知道了 k 值也可以反推，<code>i = （k + 1）/ 3 + 1</code>，顺带就可以求出 j 的值。</p><h2 id="稀疏矩阵" tabindex="-1"><a class="header-anchor" href="#稀疏矩阵" aria-hidden="true">#</a> 稀疏矩阵</h2><p>矩阵中非零元素的个数 t，相对矩阵总元素 s 来说相对非常少，即 s &gt;&gt; t 的矩阵被称为稀疏矩阵，至于这个到底是远大于多少并没有明确的指标，可凭借个人主观因素判断。</p><p>若采用常规的方法存储稀疏矩阵，则相当浪费空间，因为对于稀疏矩阵我们仅存储非零元素。因此将非零元素及相对应的行和列构成一个三元组（行标、列标、值）。此方法虽然可以节省了空间，但是也失去了随机存取的特性。</p><figure><img src="'+s+'" alt="稀疏矩阵以及对应的三元组" tabindex="0" loading="lazy"><figcaption>稀疏矩阵以及对应的三元组</figcaption></figure>',20),n=[o];function h(p,l){return e(),i("div",null,n)}const j=a(c,[["render",h],["__file","arrays-materices.html.vue"]]);export{j as default};
