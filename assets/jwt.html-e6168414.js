const e=JSON.parse(`{"key":"v-a6ca4500","path":"/study/backend/tools/jwt.html","title":"JSON Web Tokens","lang":"zh-CN","frontmatter":{"star":true,"category":"JWT","tag":["JWT","Java"],"description":"JSON Web Tokens 前世今生 当我步入开发的第一个项目就已经用上了 Token 令牌鉴权的方式，可当时并不清楚这个在请求头添加的 Bearer 字符串是什么，在走进 Token 之前，我们应该从它的前身 Session 来开始讲起。 在早期的 Web 服务应用阶段，为了解决 HTTP 协议无状态的特性带来的用户认证和会话管理问题。在没有 Session 之前，服务器无法识别连续的多个请求是否来自同一个用户，因为HTTP协议本身并不维护用户的上下文状态。随着Web应用规模的扩大，尤其是分布式系统和微服务架构的兴起，Session 集中存储在一台服务器上的方式开始暴露出可扩展性和性能瓶颈。此外，跨域请求、CSRF攻击等问题也促使开发者寻找新的解决方案。","head":[["meta",{"property":"og:url","content":"https://github.com/songbaicheng/songbaicheng.github.io/study/backend/tools/jwt.html"}],["meta",{"property":"og:site_name","content":"Baicheng's Blog"}],["meta",{"property":"og:title","content":"JSON Web Tokens"}],["meta",{"property":"og:description","content":"JSON Web Tokens 前世今生 当我步入开发的第一个项目就已经用上了 Token 令牌鉴权的方式，可当时并不清楚这个在请求头添加的 Bearer 字符串是什么，在走进 Token 之前，我们应该从它的前身 Session 来开始讲起。 在早期的 Web 服务应用阶段，为了解决 HTTP 协议无状态的特性带来的用户认证和会话管理问题。在没有 Session 之前，服务器无法识别连续的多个请求是否来自同一个用户，因为HTTP协议本身并不维护用户的上下文状态。随着Web应用规模的扩大，尤其是分布式系统和微服务架构的兴起，Session 集中存储在一台服务器上的方式开始暴露出可扩展性和性能瓶颈。此外，跨域请求、CSRF攻击等问题也促使开发者寻找新的解决方案。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-05-09T15:50:11.000Z"}],["meta",{"property":"article:author","content":"songbaicheng"}],["meta",{"property":"article:tag","content":"JWT"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:modified_time","content":"2024-05-09T15:50:11.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"JSON Web Tokens\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-05-09T15:50:11.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"songbaicheng\\",\\"url\\":\\"https://github.com/songbaicheng\\",\\"email\\":\\"songbaicheng16@163.com\\"}]}"]]},"headers":[{"level":2,"title":"前世今生","slug":"前世今生","link":"#前世今生","children":[]},{"level":2,"title":"核心概念","slug":"核心概念","link":"#核心概念","children":[]},{"level":2,"title":"JWT 简单场景案例","slug":"jwt-简单场景案例","link":"#jwt-简单场景案例","children":[{"level":3,"title":"引入依赖","slug":"引入依赖","link":"#引入依赖","children":[]},{"level":3,"title":"JWT 工具类","slug":"jwt-工具类","link":"#jwt-工具类","children":[]},{"level":3,"title":"校验 Token 过滤器","slug":"校验-token-过滤器","link":"#校验-token-过滤器","children":[]},{"level":3,"title":"生成令牌和携带令牌","slug":"生成令牌和携带令牌","link":"#生成令牌和携带令牌","children":[]}]}],"git":{"createdTime":1715269811000,"updatedTime":1715269811000,"contributors":[{"name":"songbaicheng","email":"songbaicheng16@163.com","commits":1}]},"readingTime":{"minutes":8.67,"words":2602},"filePathRelative":"study/backend/tools/jwt.md","localizedDate":"2024年5月9日","excerpt":"<h1> JSON Web Tokens</h1>\\n<h2> 前世今生</h2>\\n<p>当我步入开发的第一个项目就已经用上了 Token 令牌鉴权的方式，可当时并不清楚这个在请求头添加的 Bearer 字符串是什么，在走进<br>\\nToken 之前，我们应该从它的前身 Session 来开始讲起。</p>\\n<p>在早期的 Web 服务应用阶段，为了解决 HTTP 协议无状态的特性带来的用户认证和会话管理问题。在没有 Session<br>\\n之前，服务器无法识别连续的多个请求是否来自同一个用户，因为HTTP协议本身并不维护用户的上下文状态。随着Web应用规模的扩大，尤其是分布式系统和微服务架构的兴起，Session<br>\\n集中存储在一台服务器上的方式开始暴露出可扩展性和性能瓶颈。此外，跨域请求、CSRF攻击等问题也促使开发者寻找新的解决方案。</p>","autoDesc":true}`);export{e as data};
